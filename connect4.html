<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jeffrey Popek Portfolio - Holly Jolly Engine</title>
    <link href="https://unpkg.com/lucide-css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    
    
    <!-- Google Fonts - Kanit -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Fira+Sans:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&family=Kanit:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&family=Lato:ital,wght@0,100;0,300;0,400;0,700;0,900;1,100;1,300;1,400;1,700;1,900&display=swap" rel="stylesheet">

    <link href="styles.css" rel="stylesheet">
    
    
    <link rel="icon" type="image/png" href="assets/favicon.webp">

    
    <style>
         /* Add to style section */
         .page-background {
            background: linear-gradient(rgba(0,0,0,0.5), rgba(0,0,0,0.5)), url('/assets/ds_background.png');
            background-color: #2c2c2c;
            min-height: 100vh;
            padding-top: 60px;
        }

        .content-wrapper {
            background-color: #000000a9;
            max-width: 2000px;
            margin: 0 auto;
            box-shadow: 0 0 20px rgba(0,0,0,0.1);
            min-height: 100vh;

            /* mask-image: radial-gradient(circle, black, black 65%, transparent 85%); */
        }

        .project-header {
            padding-top: 40px;
            padding-bottom: 0;
            text-align: center;
            background: #f8f8f8;
        }

        .project-header h1 {
            font-size: 3rem;
            margin-bottom: 0rem;
            font-family: 'Lato', sans-serif;
            font-weight: 700;  /* Bold */
        }

        .project-content h2 {
            padding-bottom: 0rem; /* Adds space below "Technical Achievements" */
            font-family: 'Lato', sans-serif;
            font-weight: 700;  /* Bold */
            font-size: xx-large;
        }

        .project-content h3 {
            padding-bottom: 0rem; /* Adds space below "Technical Achievements" */
            padding-top: 3rem;
            font-family: 'Lato', sans-serif;
            font-weight: 700;  /* Bold */
            font-size: x-large;
        }

        .project-content p {
            padding-top: 1rem; /* Adds space below "Technical Achievements" */
            padding-bottom: 1rem; /* Adds space below "Technical Achievements" */
            font-family: 'Lato', sans-serif;
            font-weight: 400;  /* Regular */
            line-height: 1.6; /* Adds space between lines */
            font-size: large;
        }

        a {
            font-family: 'Lato', sans-serif;
            font-weight: 400;  /* Regular */
            text-decoration: none; /* Optional: removes underline from links */
            font-size: large;
            padding-top: 1rem;
            padding-bottom: 1rem;
        }



        body {
            font-family: 'Poppins', sans-serif;
            color: white;
        }

        .project-content {
            max-width: 1000px;
            margin: 0 auto;
            padding: 4rem 2rem;
            text-align: center;
            

            margin-top: 10; /* Ensure no extra spacing */
            padding-top: 10; /* Remove any padding pushing it down */
        }

        .project-image {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 8px;
            margin-bottom: 2rem;
        }

        .project-info-box {
            background: rgba(36, 36, 36, 0.473);
            border-radius: 8px;
            padding: 2rem;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            margin-bottom: 2rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            align-items: center;

            font-family: 'Lato', sans-serif;
            font-weight: 300; /* Bold */
        }

        /* Apply the font to individual info-items if needed */
.project-info-box .info-item {
    font-family: 'Lato', sans-serif;
    font-weight: 400;
}

/* Apply the font to the span text */
.project-info-box .info-item span {
    font-family: 'Lato', sans-serif;
    font-weight: 400;
}

        .info-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .info-item i {
            color: var(--purple);
            width: 20px;
            height: 20px;
        }

        .project-description h2 {
            color: var(--purple);
            margin-bottom: 1rem;
        }

        .project-description p {
            line-height: 1.6;
            margin-bottom: 1rem;
        }

        .info-item i {
    color: white !important;
}

i {
    margin-right: 8px; /* Adds space between the icon and text */
        }

        a i, .fa-github {
    font-size: 2rem; /* Adjust size */
    margin-right: 5px; /* Space between icon and text */
}

a:hover i, a:hover .fa-github {
    color: purple; /* Change color on hover */
}

a {
    font-size: 1.2rem; /* Makes text bigger */
    text-decoration: none; /* Removes underline */
}

.about-cta {
            display: inline-block;
            margin-top: 1rem;
            margin-right: 10px;
            padding: 0.75rem 1.5rem;
            background-color: var(--purple);
            color: white;
            text-decoration: none;
            border-radius: 4px;
            font-weight: 500;
            transition: background-color 0.2s ease;
        }

        .about-cta:hover {
            background-color: var(--purple-hover);
        }


        /* Contact Section */
.contact {
            padding: 4rem 2rem;
            background: none;
            text-align: center;
            color: white;
            font-size: 30px;
        }

        .contact-links {
            display: flex;
            justify-content: center;
            gap: 2rem;
            margin-top: 2rem;
            color: white;
            font-size: 20px;
        }

        .contact-links a {
            color: var(--purple);
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            color: white;
        }

        .contact-links a:hover {
            color: #b847ec; /* Changes text color on hover */
            text-shadow: 0 0 10px #ffffff00; /* Adds a glow effect */
        }
        

        .contact h2 {
    text-align: center;
    position: relative;
    padding-bottom: 10px; /* Space between text and line */
}

.contact h2::after {
    content: "";
    display: block;
    width: 50%; /* Adjust width as needed */
    height: 2px; /* Line thickness */
    background-color: white; /* Adjust color */
    margin: 10px auto 0; /* Center the line */
}

.contact h3 {
    padding-top: 0.5rem;
    font-size: 25px;
}

        
    </style>
</head>
<body>
            <!-- Where you want the header to go -->
        <div id="header-placeholder"></div>

        <!-- This script loads the header -->
        <script>
        fetch('header.html')
            .then(response => response.text())
            .then(data => {
            document.getElementById('header-placeholder').innerHTML = data;
            });
        </script>

    <div class="page-background">
        <div class="content-wrapper">
            <!-- <section class="project-header">
                <h1>Poly-Vinyl Pests!</h1>
            </section> -->

            <div class="project-content">
                <img src="/assets/connect4/cf-thumbnail.PNG" alt="Poly-Vinyl Pests" class="project-image">
                <div class="project-info-box">
                    <div>
                        <h2>Networked Connect 4</h2>
                    </div>

                    <div class="info-item">
                        
                        <span><i class="fa-solid fa-user"></i> Role: Network Programmer</span>
                    </div>

                    
                    
                    <div class="info-item">
                        <span><i class="fa-solid fa-clock"></i> Project Length: 1 Week</span>
                    </div>

                    <div class="info-item">
                        
                        <span><i class="fa-solid fa-users"></i> Team Size: 2</span>
                    </div>

                    <div class="info-item">
                        <span><i class="fa-solid fa-wrench"></i> Engine: Raylib & C++</span>
                    </div>
                </div>

                <div class="project-description">
                    <p>
                        The goal of this project is to allow two players to play Connect Four over a network, where one user hosts the game and another joins. Each player can interact with the game board through keyboard input, and turns are synchronized between clients using custom networking logic. This project demonstrates key concepts in graphics programming, basic input handling, and client-server networking. 

                    </p>


                    <div class="video-container">
                        <video width="100%" height="500" controls>
                            <source src="/assets/connect4/cf-gameplay.mp4" type="video/mp4">
                            Your browser does not support the video tag.
                        </video>
                        </div>

                    <!-- <div class="video-container">
                        <iframe width="100%" height="500" src="https://www.youtube.com/embed/psUynFL7BK8?si=3X_nD0jEOa66NzLu" frameborder="0" allowfullscreen></iframe>
                    </div> -->

                    
                    <a href="https://github.com/JeffreyPopek/Networked-Connect-4" target="_blank" class="about-cta">GitHub</a>
                   </div>

                

                
                <div class="project-content">
                    <h2>Setting Up the Core Components</h2>
                
                    <p>
                        At the top of the program, we define several constants and global variables that control the game’s behavior. 
                        These include the number of rows and columns on the board, the size of each cell (in pixels), and the IP 
                        address and port used for network communication. The game board itself is represented by a 2D array of 
                        <code>Player</code> enums, which can be either <code>NONE</code>, <code>PLAYER1</code>, or <code>PLAYER2</code>. 
                        These enum values are used to track the state of each cell on the board.                        
                    </p>

                    <p>
                        Additional flags like <code>isConnected</code>, <code>waitingForConnection</code>, 
                        <code>waitingForResponse</code>, and <code>resetGame</code> help manage the overall flow of the game and ensure 
                        proper sequencing of turns. The current player and their selected column are tracked using dedicated variables, 
                        and the UI updates dynamically based on these states. There are also color variables and winner status flags used 
                        to render the correct visuals and end-game messages.
                    </p>


                    <img src="/assets/connect4/cf-globals.png" alt="a" class="project-image">

                </div>
                
                <div class="project-content">
                    <h2>Game Logic</h2>
                

                    <p>
                        The first major function is <code>DropPiece(int col, Player player)</code>, which attempts to drop a game piece 
                        into the selected column. This function starts from the bottom of the column and works upward, checking each cell 
                        for an empty space. Once it finds an empty spot, it places the player’s piece there and returns <code>true</code>. 
                        If the column is already full, it returns <code>false</code>.
                    </p>

                    <img src="/assets/connect4/cf-placing.gif" alt="a" class="project-image">


                    <p>
                        After each move, the program checks for a win using the <code>CheckWin(Player player)</code> function. This function 
                        looks in all four directions—horizontal, vertical, and both diagonals—to find four consecutive cells containing the 
                        current player's pieces. If such a pattern is detected, the game ends with that player declared the winner. If not, 
                        and the board is full, the game ends in a draw. Otherwise, the function simply switches turns to the next player and 
                        updates the UI accordingly.
                    </p>

                    <img src="/assets/connect4/cf-checkwin.gif" alt="a" class="project-image">


                    <p>
                        To determine if the board is full, the <code>IsBoardFull()</code> function loops through each cell, returning 
                        <code>false</code> immediately if it finds an empty one. If the loop completes without finding any empty cells, the 
                        function returns <code>true</code>, signaling a draw.
                    </p>
                
                    <img src="/assets/connect4/cf-boardfull.PNG" alt="a" class="project-image">

                    

                    <p>
                        Input is handled in <code>CheckInput()</code>, which listens for arrow keys to move the column selector, and for 
                        the space or enter key to drop a piece. If the game is over, pressing the ‘R’ key resets the board. The function 
                        returns <code>true</code> if any meaningful input is received, which helps synchronize state across the network.
                    </p>
                </div>
                
                <div class="project-content">
                    <h2>Rendering the Game Board</h2>
                

                    <p>
                        The <code>DrawBoard()</code> function is responsible for rendering the entire game screen. It starts by drawing 
                        messages to guide the user based on whether they are hosting or joining a game. If the game is not yet connected, 
                        the screen prompts the user to press either ‘H’ or ‘J’ to host or join, respectively. If a connection is being 
                        established, it displays a “Waiting…” message.
                    </p>

                    <img src="/assets/connect4/cf-joining.gif" alt="a" class="project-image">


                    <p>
                        When the game is in progress, the selected column is highlighted with an arrow and a preview of the piece that 
                        will be placed if the player acts. The function then iterates through the entire game board and draws a colored 
                        circle in each cell based on the occupying player. Finally, the UI displays win or draw messages as appropriate, 
                        along with prompts to reset the game.
                    </p>

                </div>
                
                <div class="project-content">
                    <h2>Handling Networking</h2>
            
                    <p>
                        To enable multiplayer functionality, we need to send and receive the game state over the network. This is where 
                        Socklib comes in. The <code>ReceiveData(Socket& socket, std::string& data)</code> function reads data from the 
                        socket and stores it in a string, which can later be used to update the game state. This function returns 
                        <code>true</code> if any data is received, ensuring the game can continue when a response arrives from the other player.
                    </p>

                    <img src="/assets/connect4/cf-receivedata.PNG" alt="a" class="project-image">


                    <p>
                        The entire game state is serialized into a string using the <code>SerializeBoard()</code> function. This includes 
                        the current player, turn flags, column selection, piece color, and the complete board layout. We use 
                        <code>std::stringstream</code> to construct this string, which can easily be sent over the network.          
                    </p>

                    <img src="/assets/connect4/cf-serializeboard.PNG" alt="a" class="project-image">


                    <p>
                        On the receiving end, <code>DeserializeBoard(const std::string& data)</code> parses the string back into its original 
                        components and updates the game state accordingly. This ensures both players remain synchronized and see the same board 
                        at all times. We also set a flag here to indicate that it’s now the other player’s turn to act.
                    </p>

                    <img src="/assets/connect4/cf-deserializeboard.PNG" alt="a" class="project-image">
                </div>
                
                <div class="project-content">

                    <h2>Game Initialization</h2>
        
                    <p>
                        The <code>main()</code> function initializes the Raylib window with dimensions calculated from the board size and 
                        cell size. It sets the target FPS for a consistent experience and displays an initial prompt for the user to choose 
                        whether to host or join a game. Based on this input, the program calls either <code>RunHost()</code> or 
                        <code>RunClient()</code> and begins the game loop.
                    </p>

                    <img src="/assets/connect4/cf-main.PNG" alt="a" class="project-image">


                    <h3>Running as Host or Client</h3>

                    <p>
                        Depending on the user’s choice at the start of the game, the program enters either <code>RunHost()</code> or 
                        <code>RunClient()</code>. If the user chooses to host, <code>RunHost()</code> initializes the socket library, binds 
                        to a port, and listens for incoming connections. Once a client connects, the game begins, with the host assigned as 
                        <code>PLAYER1</code>. The host sends the initial game state, and then both sides alternate turns, sending and 
                        receiving serialized board states.                        
                    </p>

                    <img src="/assets/connect4/cf-runhost.PNG" alt="a" class="project-image">




                   
                    <p>
                        If the user chooses to join, <code>RunClient()</code> attempts to connect to the host using the IP and port defined 
                        earlier. Once connected, the client becomes <code>PLAYER2</code> and waits to receive the game state before taking 
                        any actions. Each player can only act on their turn, as enforced by the <code>waitingForResponse</code> flag. This 
                        helps prevent race conditions and ensures the game remains in sync.
                    </p>
                </div>
                
            
                
                <div class="project-content">
                    <h2>What I Learned</h2>
                    <p>
                        This project showcases how to build a complete networked game in C++ using Raylib and Socklib. By combining 2D 
                        rendering, user input, and network synchronization, we created a fully playable version of Connect Four. This is 
                        a solid foundation that can be expanded into more complex multiplayer games or adapted for other genres.
                    </p>

                    <p>
                        Networking was intentionally kept minimal using Socklib, focusing on transmitting the entire game state as a string. 
                        This avoids the complexity of managing multiple types of messages and simplifies the synchronization process. The 
                        use of serialization ensures that the game remains turn-based and avoids mid-turn conflicts.
                    </p>
                </div>

            
                


                <section class="contact">
                    <h2>Contact Me</h2>
                    <h3>jeffreypopek@gmail.com</h3>
                    <div class="contact-links">
                            <a href="https://www.linkedin.com/in/jeffreypopek/" target="_blank" class="about-cta">LinkedIn</a>
                            <a href="https://github.com/JeffreyPopek" target="_blank" class="about-cta">Github</a>
                            <a href="https://jeffreypopek.itch.io/" target="_blank" class="about-cta">Itch.io</a>
                            <a href="/assets/JeffreyPopek_Resume.pdf" target="_blank" class="about-cta">Resume</a>
                       </div>
                </section>

                <!-- DO NOT USE OR DELETE -->
                <!-- <div class="project-content">
                    <h2>Contributions</h2>
                    <p></p>
                
                    <img src="/assets/pvp/pvpGameLoopDiagram.png" alt="Technical Achievements" class="project-image">
                </div> -->

                   
            </div>
        </div>
    </div>
</body>
</html>

